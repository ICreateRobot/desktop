const {app, shell} = require('electron');
const AbstractWindow = require('./abstract');
const {translate, getStrings, getLocale} = require('../l10n');
const {APP_NAME} = require('../brand');
const settings = require('../settings');
const {isUpdateCheckerAllowed} = require('../update-checker');
const RichPresence = require('../rich-presence');

const {ipcMain}=require('electron/main')

const { SerialPort } = require('serialport');
const path = require('path');

const { BrowserWindow } = require('electron');

const {getCloseBn,setCloseBn} = require('../../utils/closeBn')
// const {getSocket} = require('../../utils/socket')
const extensions = require('../../utils/extensionWho')


const DAPjs = require('dapjs');
const { DAPLink } = DAPjs;
const usb = require('usb');
const { ReadlineParser } = require('@serialport/parser-readline');
const {MicropythonFsHex }  = require('@microbit/microbit-fs');
const { microbitBoardId } = require('@microbit/microbit-universal-hex');
let options_mode ='full';//ÁÉßÂΩïÊ®°Âºè---fullÔºöÂÆåÊï¥Ê®°ÂºèÔºõincrementalÔºöÂ¢ûÈáèÊ®°Âºè



const IntelHex = require('intel-hex');
const fs = require('fs');
// const parser = require('@serialport/parser-readline');
const {setPort,getPort,getDeviceState,setDeviceState,setPortCom,getPortCom} = require('../../utils/port')
// const axios = require('axios');


const WebSocket = require('ws');
const iconv = require('iconv-lite');

const currentWifi=require('../../utils/currentWifi')

const { exec } = require('child_process');

const si = require('systeminformation');

const netTimer=require('../../utils/timer')

const wifi = require('node-wifi');
const os = require('os');



const sudo = require('sudo-prompt');
const history = require('../../utils/historyIp')

let esptool
// require = require('esm')(module)
// esptool =require('../../utils/espTool')
const net = require("net");
const QRCode = require('qrcode');

// const netTimer=require('../../utils/timer');
// const { name } = require('file-loader');
const ssid = 'MyHotspot'; // Wi-Fi ÂêçÁß∞
const password = '12345678'; // Wi-Fi ÂØÜÁ†Å

const currentEspIp = require('../../utils/currentEspIp')


const {getWin,setWin} = require('../../utils/win')
const {getCode,setCode,getDown,setDown} = require('../../utils/tempCode')

const {getDistance,setDistance} = require('../../utils/distance')
// const {getDistance,setDistance} = require('../../node_modules/scratch-vm/src/util/action')
const {setSocket,getSocket,getBricksSocket,getBricksMotor} = require('../../utils/socket')
const BleConnectWindow =require('./ble-connect')

let bluetoothPinCallback
let selectBluetoothCallback

let THIS
let isClosed

const Readline = require('@serialport/parser-readline')
// const parser = require('@serialport/parser-readline');
const socket =require('../../utils/socket')

//---------------------wifiÊ®°Âºè-------------------------
function detectPreferredInterface() {
  return new Promise((resolve, reject) => {
    exec('netsh wlan show interfaces', { encoding: 'utf8' }, (error, stdout, stderr) => {
      if (error) {
        console.error(`‚ùå ERROR: ${error.message}`);
        return reject(error);
      }

      if (stderr) {
        console.error(`‚ö†Ô∏è stderr: ${stderr}`);
        // ÂèØ‰ª•ÈÄâÊã©ÁªßÁª≠Ôºå‰πüÂèØ‰ª• reject
      }

      // Ê≠£ÂàôÂåπÈÖçÂÉè WLAN 1„ÄÅWLAN 5 Á≠âÊé•Âè£Âêç
      const regex = /WLAN\s*\d+/i;
      const match = stdout.match(regex);
      const preferredInterface = match ? match[0].trim() : null;

      console.log('‚úÖ Detected interface:', preferredInterface);
      resolve(preferredInterface);
    });
  });
}

detectPreferredInterface()
  .then(iface => {
    wifi.init({ iface });  // null ‰ºöËá™Âä®Áî®ÈªòËÆ§Êé•Âè£
    console.log('üì∂ Using interface:', iface || '(default)');
  })
  .catch(err => {
    console.error('‚ùå Failed to detect interface:', err);
  });


  //-------------------‰∫åÁª¥Á†ÅÊ®°Âºè--------------------

  function hexToByteArray(hex) {
    const byteArray = [];
    for (let i = 0; i < hex.length; i += 2) {
      byteArray.push(parseInt(hex.substr(i, 2), 16));
    }
    return byteArray;
  }
  
  
  const baseIp = "192.168.137."; // ‰Ω†ÁöÑÁîµËÑëÁÉ≠ÁÇπ IP ÊÆµÔºà‰æãÂ¶Ç 192.168.137.XÔºâ
  const port = 8082; // ESP32 ËøêË°å WebSocket ÁöÑÁ´ØÂè£
  const TimeOut = 500; // Ë∂ÖÊó∂Êó∂Èó¥ÔºàÊØ´ÁßíÔºâ
  
  let checking=false
  
  // async function checkIp(ip) {
  //     return new Promise((resolve) => {
  //         const socket = new net.Socket();
  //         socket.setTimeout(TimeOut);
  
  //         socket.on("connect", () => {
  //             console.log(`ÊâæÂà∞ ESP32: ${ip}`);
  //             socket.destroy();
  //             // socket.close()
  //             resolve(ip);
  //         });
  
  //         socket.on("error", (e) => {
  //           // console.log(e)
  //           // socket.destroy();
  //             resolve(null);
  //         });
  
  //         socket.on("timeout", () => {
  //           // console.log('timeout')
  //           // socket.destroy();
  //             resolve(null);
  //         });
  
  //         socket.connect(port, ip);
  //     });
  // }
  
  // async function scanNetwork() {
     
  //     const tasks = [];
  //     for (let i = 2; i < 255; i++) {
  //         tasks.push(checkIp(baseIp + i));
  //     }
  
  //     const results = await Promise.all(tasks);
  //     const espIp = results.find((ip) => ip !== null);
  
  //     if (espIp) {
  //         console.log(`ESP32 IP Âú∞ÂùÄ: ${espIp}`);
  //         currentEspIp.setIp(espIp)
  //         clearInterval(netTimer.getTimer())
  //         // await new Promise(resolve => setTimeout(resolve, 1000));
  //         if(getSocket()){
  //             getSocket().send(JSON.stringify({
  //               type: 'whatIp',
  //               data: { message: espIp }
  //             }))
  //         }
  //     } else {
  //         console.log("Êú™ÊâæÂà∞ ESP32");
  //     }
  
  // }

  let isScanning = false;
  let scanAbort = false;

  function checkIp(ip) {
      return new Promise((resolve) => {
          if (scanAbort) return resolve(null);

          const socket = new net.Socket();
          socket.setTimeout(TimeOut);

          socket.on("connect", () => {
              console.log(`ÊâæÂà∞ ESP32: ${ip}`);
              socket.destroy();
              resolve(ip);
          });

          socket.on("error", () => resolve(null));
          socket.on("timeout", () => resolve(null));

          socket.connect(port, ip);
      });
  }

  async function scanNetwork() {
      if (isScanning) return;
      isScanning = true;
      scanAbort = false;

      for (let i = 2; i < 255; i++) {
          const ip = baseIp + i;

          // Âú®ÊØèÊ¨° checkIp Ë∞ÉÁî®ÂâçÂà§Êñ≠ÊòØÂê¶Â∑≤‰∏≠Ê≠¢
          checkIp(ip).then((result) => {
              if (result && !scanAbort) {
                  scanAbort = true; // ÂÅúÊ≠¢ÂÖ∂‰ªñ‰ªªÂä°ÁöÑÁªßÁª≠ÊâßË°å
                  console.log(`ESP32 IP Âú∞ÂùÄ: ${result}`);
                  currentEspIp.setIp(result);
                  clearInterval(netTimer.getTimer());

                  if (getSocket()) {
                      getSocket().send(JSON.stringify({
                          type: 'whatIp',
                          data: { message: result }
                      }));
                  }
                  if(!isClosed){
                    THIS.window.close()
                  }

              }
          });

          // Âú®ÊâæÂà∞ IP ÂêéË∑≥Âá∫ for Âæ™ÁéØ
          if (scanAbort) break;
          await new Promise(res => setTimeout(res, 20)); // ËäÇÊµÅÔºåÈÅøÂÖçËøáÂø´
      }

      isScanning = false;
  }

class ConnectWindow extends AbstractWindow {
  constructor () {
    super();

    this.window.setTitle(`${translate('connect-device.title')} - ${APP_NAME}`);
    this.window.setMinimizable(false);
    this.window.setMaximizable(false);
    // this.window.setResizable(false)
    // console.log(this.window.navigator);
    // this.window.webContents.openDevTools()
    isClosed=false
    THIS=this
    const ipc = this.window.webContents.ipc;

    
    ipc.on('get-translate', (event) => {
      event.returnValue = {
        locale: getLocale(),
        strings: getStrings()
      }
    });

    ipc.on('get-extension', async(event) => {

      if(extensions.getExtension()!=1 && extensions.getExtension()!=2 && extensions.getExtension()!=3){
        this.window.close()
        await new Promise(resolve => setTimeout(resolve, 200));
        const MasterWindow = require('./master')
        MasterWindow.show()
        
      }
      console.log('________________________')
      event.returnValue = {
        wifi: extensions.getExtension(),
      }
    });

    this.window.on('close', (event) => {
      console.log('ConnectWindow is about to close');
      // ÂèØÂú®ËøôÈáåÂÅöÊ∏ÖÁêÜÂ∑•‰ΩúÔºåÊØîÂ¶ÇÊñ≠ÂºÄsocketËøûÊé•„ÄÅ‰øùÂ≠òÁä∂ÊÄÅÁ≠â
      isClosed=true
      if(getSocket()){
        getSocket().send(JSON.stringify({
          type: 'addLoad',
          data: { message: false }
        }))
      }
      if (netTimer.getTimer()) {
        clearInterval(netTimer.getTimer());
      }
    });
//--------------wifiÊ®°Âºè-----------------------
     // Êâ´Êèè Wi-Fi ÁΩëÁªú
    ipc.handle('scan-wifi', async () => {
      // exec('netsh wlan show networks', (error, stdout, stderr) => {
      //   if (error) {
      //       console.error(`exec error: ${error}`);
      //       return;
      //   }
      //   console.log(`stdout: ${stdout}`);
      //   console.error(`stderr: ${stderr}`);
      // });
      return new Promise((resolve, reject) => {
        
        wifi.scan((error, networks) => {
          if (error) {
            reject(error);
          } else {
            resolve(networks);  // ËøîÂõûÂèØÁî®ÁöÑ Wi-Fi ÁΩëÁªúÂàóË°®
          }
        });
      });
    });

    ipc.on('current-wifi', (event) => {
      event.returnValue = {
        wifi: currentWifi.getWifi(),
      }
    });


    async function checkWifi() {
      try {
        const interfaces = await si.networkInterfaces();
        const wifiInterface = interfaces.find(iface => 
          iface.type === 'wireless' && iface.operstate === 'up'
        );
        return !!wifiInterface;
      } catch (error) {
        console.error('Error:', error);
        return false;
      }
    }


      function getCurrentSSID(callback) {
        exec('netsh wlan show interfaces', (err, stdout) => {
          if (err) return callback(err);
      
          const match = stdout.match(/^\s*SSID\s*:\s(.+)$/m);
          if (match) {
            callback(null, match[1].trim());
          } else {
            callback(null, null); // Ê≤°ÊúâËøûÊé•
          }
        });
      }
            
          
    setInterval(()=>{
      getCurrentSSID((err, ssid) => {
        if (err) {
          console.error('Error:', err);
        } else if (currentWifi.getWifi() && ssid !== currentWifi.getWifi()) {
          console.log('Disconnected or connected to the wrong network');
          currentWifi.setWifi('')
          if(getSocket()){
            // console.log('ÂèØËÉΩÂèëÈÄÅ‰∫Ü')
            getSocket().send(JSON.stringify({
              type: 'wifiIsConnected',
              data: { message: false }
            }))
          }
        } else {
          // console.log('Connected to target SSID');
        }
      });
    },3000)
    

      function checkNetworkInterface(ssid) {
        const interfaces = os.networkInterfaces();
        for (let iface in interfaces) {
          for (let details of interfaces[iface]) {
            if (details.family === 'IPv4' && !details.internal) {
              console.log(`Connected Wi-Fi IP: ${details.address}`);
              return true;  // ËÆæÂ§áÊàêÂäüËé∑Âèñ‰∫Ü IPÔºåËØ¥ÊòéËøû‰∏ä Wi-Fi
            }
          }
        }
        return false;  // ËÆæÂ§áÊ≤°ÊúâËé∑Âèñ IPÔºåËØ¥Êòé Wi-Fi ÂèØËÉΩÊ≤°Ëøû‰∏ä
      }

      // ÈÄöÁî®ÊñπÊ≥ïÔºöÊ£ÄÊü•ÊòØÂê¶ËøûÊé•Âà∞ÊåáÂÆöWi-Fi
      function checkConnectedToSSID(ssid) {
        return new Promise((resolve) => {
          const command = process.platform === 'win32' ?
            `netsh wlan show interfaces | findstr /C:"SSID" | findstr "${ssid}"` :
            `iwgetid -r | grep "^${ssid}$"`;

          exec(command, (error, stdout) => {
            resolve(!error && stdout.includes(ssid));
          });
        });
      }

      // ÊîπËøõÂêéÁöÑËøûÊé•ÈÄªËæë
      ipc.handle('connect-wifi', async (event, ssid, password) => {
        console.log('-------------------')
        return new Promise(async (resolve, reject) => {
          const maxRetries = 3;
          let retries = 0;

          const attemptConnect = async () => {
            try {
              await new Promise((innerResolve, innerReject) => {
                wifi.connect({ ssid, password }, (error) => {
                  error ? innerReject(error) : innerResolve();
                });
              });

              // Á≠âÂæÖÂπ∂È™åËØÅËøûÊé•
              const isConnected = await waitForConnection(ssid, 15000); // ÊúÄÂ§öÁ≠â15Áßí
              if (isConnected) {
                console.log("connected----------")
                currentWifi.setWifi(ssid);

                clearInterval(netTimer.getTimer())
                if(getSocket()){
                  console.log('ÂèØËÉΩÂèëÈÄÅ‰∫Ü')
                  getSocket().send(JSON.stringify({
                    type: 'whatIp',
                    data: { message: '192.168.4.1' }
                  }))
                }
                resolve("connected");
              } else {
                console.log("timeout------------")
                throw new Error("timeout");
              }
            } catch (error) {
              if (retries++ < maxRetries) {
                setTimeout(attemptConnect, 2000); // 2ÁßíÂêéÈáçËØï
              } else {
                console.log(`connect failed--------------: ${error.message}`)
                reject(`connect failed: ${error.message}`);
              }
            }
          };

          attemptConnect();
        });
      });

      // Á≠âÂæÖËøûÊé•ÂÆåÊàêÁöÑËæÖÂä©ÂáΩÊï∞
      async function waitForConnection(ssid, timeoutMs) {
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
          if (await checkConnectedToSSID(ssid)) return true;
          await new Promise(resolve => setTimeout(resolve, 1000)); // ÊØèÁßíÊ£ÄÊü•‰∏ÄÊ¨°
        }
        return false;
      }



    // ÁõëÂê¨Êù•Ëá™Ê∏≤ÊüìËøõÁ®ãÁöÑÊ∂àÊÅØ
    ipc.handle('whatssid', async (event, arg) => {
      console.log('Êî∂Âà∞Ê∂àÊÅØ:', arg);
      return currentWifi.getWifi()

      // return new Promise((resolve, reject) => {
      //   wifi.getCurrentConnections((error, currentConnections) => {
      //     if (error) {
      //       console.error('Ëé∑ÂèñÂΩìÂâç Wi-Fi ËøûÊé•Â§±Ë¥•:', error);
      //       reject(error);
      //       return;
      //     }
    
      //     if (currentConnections.length > 0) {
      //       let ssid = currentConnections[0].ssid;
    
      //       // **Âº∫Âà∂ËΩ¨Êç¢ÁºñÁ†Å‰∏∫ UTF-8**
      //       ssid = iconv.decode(Buffer.from(ssid, 'binary'), 'utf-8');
    
      //       console.log('ÂΩìÂâçËøûÊé•ÁöÑ Wi-Fi SSID:', ssid);
      //       resolve(ssid);
      //     } else {
      //       console.log('ÂΩìÂâçÊú™ËøûÊé•Âà∞ Wi-Fi');
      //       resolve(null);
      //     }
      //   });
      // });
      
    });

    ipc.handle('close', async (event, flag) => {
      if(flag){


        // if(getSocket()){
        //   console.log('postMessage')
        //   getSocket().send(JSON.stringify({
        //     type: 'wifi',
        //     data: { message: true }
        //   }))
        // }
        if (this.window && !this.window.isDestroyed()) {
          setTimeout(() => {
            this.window.close();
          }, 200); // Ê∑ªÂä†Áü≠ÊöÇÂª∂ËøüÁ°Æ‰øùÁî®Êà∑‰ΩìÈ™å
        }

        
      }
    })



    ipc.handle('disConn', async (event) => {
      console.log('--------------------------')
      // Êñ≠ÂºÄÂΩìÂâçËøûÊé•ÁöÑ Wi-Fi ÁΩëÁªú
      currentWifi.setWifi('')
      wifi.disconnect((err) => {
        if (err) {
            console.error('Êñ≠ÂºÄËøûÊé•Â§±Ë¥•:', err);
            return;
        }
        console.log('ÊàêÂäüÊñ≠ÂºÄÂΩìÂâç Wi-Fi ÁΩëÁªú');
      });
    })

    ipc.handle('change-name', async (event,name) => {

      // let jsonData={
      //   "command": "update_ap",
      //   "params": 
      //    {
      //       "ssid": name,
      //   }
      // }
      
      // const Socket = new WebSocket('ws://192.168.4.1:8084');
                    
      // Socket.addEventListener('open', (event) => {


      //   Socket.send(JSON.stringify(jsonData))
        

      // });

      // Socket.addEventListener('message', (event) => {
      //   if(event.data=='success'){
      //     Socket.close()
      //   }
          
      // })

      return new Promise((resolve, reject) => {
        let jsonData = {
            "command": "update_ap",
            "params": {
                "ssid": name,
            }
        };

        const Socket = new WebSocket('ws://192.168.4.1:8084');

        // ÁõëÂê¨ WebSocket ËøûÊé•ÊâìÂºÄ‰∫ã‰ª∂
        Socket.addEventListener('open', () => {
            Socket.send(JSON.stringify(jsonData));
        });

        // ÁõëÂê¨ WebSocket Ê∂àÊÅØ‰∫ã‰ª∂
        Socket.addEventListener('message', (event) => {
            if (event.data === 'success') {
                console.log('success')
                Socket.close();
                resolve(true); // ÊàêÂäüÂêéËøîÂõû true
            }
        });
      })

    })


    //--------------‰∫åÁª¥Á†ÅÊ®°Âºè--------------------
      ipc.on('get-std', (event) => {
          event.returnValue = {
            stdout:false
          }
        });
    
      ipc.handle('wifi-info', async (event, info) =>{
  
  
        try {
          
          // ÁîüÊàê Wi-Fi ÈÖçÁΩÆÂ≠óÁ¨¶‰∏≤
          const wifiConfig = `WIFI:T:WPA;S:${info.name};P:${info.password};;`;
  
          // ÁîüÊàê‰∫åÁª¥Á†ÅÔºàËøîÂõû PromiseÔºâ
          const qrUrl = await QRCode.toDataURL(wifiConfig);
  
          console.log('üì∑ ÁîüÊàêÁöÑ‰∫åÁª¥Á†Å URL:', qrUrl);
  
          if(info.isConnect){
            if(getSocket()){
              getSocket().send(JSON.stringify({
                type: 'addLoad',
                data: { message: true }
              }))
            }
            if (netTimer.getTimer()) {
              clearInterval(netTimer.getTimer());
            }

            netTimer.setTimer(setInterval(async()=>{
              // console.log('newTime')
                scanNetwork()
    
                
            },5000))
          }
          
          // ËøîÂõû‰∫åÁª¥Á†Å URL ÁªôÊ∏≤ÊüìËøõÁ®ã
          return qrUrl;
  
  
  
        } catch (err) {
            console.error('‚ùå ÁîüÊàê‰∫åÁª¥Á†ÅÂ§±Ë¥•:', err);
            throw err;
        }
      })
  
  
  
  
      ipc.handle('usb-wifi-info', async (event, info) =>{
  
  
          try {
          // üîß 1. ÁîüÊàêÂëΩ‰ª§Â≠óÁ¨¶‰∏≤
          const command = `netsh wlan stop hostednetwork && netsh wlan set hostednetwork mode=allow ssid=${info.name} key=${info.password} && netsh wlan start hostednetwork`;
          
          // üîß 2. sudo-prompt ÈÄâÈ°π
          const options = {
            name: 'ESP32 Hotspot Manager',
          };
  
          // ‚úÖ 3. Â∞Ü sudo.exec ÂåÖË£Ö‰∏∫ Promise
          const execAsAdmin = () =>
            new Promise((resolve, reject) => {
              sudo.exec(command, options, (error, stdout, stderr) => {
                if (error) {
                  console.error('‚ùå failed to start hotspot:', error);
                  console.error('üìÑ stderr:', stderr);  // üëà ÂÖ≥ÈîÆË∞ÉËØï‰ø°ÊÅØ
                  reject(error);
                } else {
                  console.log('‚úÖ Hotspot started:\n', stdout);
                  resolve(stdout);
                }
              });
            });
  
          // ‚úÖ 4. Á≠âÂæÖÂëΩ‰ª§ÊâßË°åÂÆåÊàê
          await execAsAdmin();
  
          // ‚úÖ 5. ÂëΩ‰ª§ÊàêÂäüÂêéÁîüÊàê‰∫åÁª¥Á†Å
          const wifiConfig = `WIFI:T:WPA;S:${info.name};P:${info.password};;`;
          const qrUrl = await QRCode.toDataURL(wifiConfig);
          console.log('üì∑ ÁîüÊàêÁöÑ‰∫åÁª¥Á†Å URL:', qrUrl);
  

          if(info.isConnect){
            if(getSocket()){
              getSocket().send(JSON.stringify({
                type: 'addLoad',
                data: { message: true }
              }))
            }
            

              // ‚úÖ 6. ËÆæÁΩÆÁΩëÁªúÊâ´ÊèèÂÆöÊó∂Âô®
            if (netTimer.getTimer()) {
              clearInterval(netTimer.getTimer());
            }
    
            netTimer.setTimer(setInterval(() => {
              scanNetwork(); // ‰Ω†Ëá™ÂÆö‰πâÁöÑÂáΩÊï∞
            }, 5000));

          }
        
  
          // ‚úÖ 7. ËøîÂõû‰∫åÁª¥Á†Å URL ÁªôÊ∏≤ÊüìËøõÁ®ã
          return qrUrl;
  
        } catch (err) {
          console.error('‚ùå Êï¥‰∏™ÊµÅÁ®ãÂ§±Ë¥•:', err);
          throw err;
        }
      })
  
  
      ipc.handle('set-history', async (event, info) =>{

        console.log('*****************');
        
  
        fetch('http://localhost:3000/save-data', {
          method: 'POST',
          headers: {
            'Content-Type': 'text/plain'
          },
          body: `ÁÉ≠ÁÇπÂêçÁß∞: ${info.name}\nÁÉ≠ÁÇπÂØÜÁ†Å: ${info.password}`
        })
        .then(response => response.text())
        .then(result => console.log(result))
        .catch(error => console.error('ÈîôËØØ:', error));
        history.setName(info.name)
        history.setPass(info.password)
      })
  
  
  
      fetch('http://localhost:3000/read-data')
        .then(res => res.json())
        .then(data => {
          const ssid = data.ssid;
          const password = data.password;
          console.log('ÁÉ≠ÁÇπÂêçÁß∞:', ssid);
          console.log('ÁÉ≠ÁÇπÂØÜÁ†Å:', password);
  
          history.setName(ssid)
          history.setPass(password)
        });
      ipc.on('get-history', (event) => {
        
        event.returnValue = {
          name:history.getName(),
          pass:history.getPass()
        }
      });

      //------------ble----------------
      ipc.handle('open-ble', async (event, info) =>{

       if(info){
         if(getWin()){
          getWin().show()
        }else{
          BleConnectWindow.show();
        }
       }
      })

      //----------------serial---------------------
      ipc.on('get-strings', (event) => {
        event.returnValue = {
          locale: getLocale(),
          strings: getStrings()
        }
      });

      async function sendSerialCommand(command, delay = 50) {
        console.log('111111111111111111111111111111111111111')
          return new Promise((resolve, reject) => {
            getDeviceState().serialPort.write(command, err => {
              if (err) return reject(err);
              setTimeout(resolve, delay);
            });
          });
        }
  
  
      let PORT
      // let portCom=''
       ipc.on('what-port-connect', (event) => {
          event.returnValue = {
            port: getPortCom()
          }
        });
      ipc.handle('send-connect-port', async (event, port) =>{
        // console.log(port)
  
        // // ÂàõÂª∫‰∏Ä‰∏™ SerialPort ÂØπË±°
        // PORT = new SerialPort({
        //     path: port, // ‰∏≤Âè£ÂêçÁß∞
        //     baudRate: 115200, // Ê≥¢ÁâπÁéá
        //     dataBits: 8, // Êï∞ÊçÆ‰Ωç
        //     stopBits: 1, // ÂÅúÊ≠¢‰Ωç
        //     parity: 'none' // Ê†°È™å‰Ωç
        // },(err) =>{
        //   console.log(PORT)
        // })
  
  
        // // ÁõëÂê¨ÊâìÂºÄ‰∫ã‰ª∂
        // PORT.on('open', () => {
        //   console.log('Port opened successfully');
        //   console.log(PORT)
        //   setPort(PORT)
        //   portCom=port
        //   if(socket.getSocket()){
        //     socket.getSocket().send(JSON.stringify({
        //       type: 'isOpenPort',
        //       data: { message: true }
        //     }))
        //   }
        //   console.log('GETPORT: ')
        //   console.log(getPort())
        //   ipc.on('is-connected', (event) => {
        //     event.returnValue = {
        //       flag: true
        //     }
        //   });
        //   // try {
        //   //   let startMsg=[0xAF,0x04,0x96,0x00,0x01,0x4a]
        //   //   const data1 = new Uint8Array(startMsg);
        //   //   PORT.write(data1);
        //   // }
        //   // catch (err) {
        //   //   console.log('ÂèëÈÄÅÊï∞ÊçÆÂ§±Ë¥•: ' + err.message+'\n');
        //   // }
        //   // // ÂàõÂª∫Ëß£ÊûêÂô®
        //   // const parserInstance = PORT.pipe(new parser({ delimiter: '\r\n' }));
        //   // // ÁõëÂê¨Êï∞ÊçÆ
        //   // parserInstance.on('data', (data) => {
        //   //   console.log(`Received: ${data}`);
        //   // });
        
        // });
    
  
        // PORT.on('close',()=>{
        //   console.log('Port closed')
        //   if(socket.getSocket()){
        //     socket.getSocket().send(JSON.stringify({
        //       type: 'isOpenPort',
        //       data: { message: false }
        //     }))
        //   }
        // })
        // // ÁõëÂê¨ÈîôËØØ‰∫ã‰ª∂
        // PORT.on('error', (err) => {
        // console.error('Serial port error:', err);
        // });
  
        // let bufferData = '';
        // PORT.on('data', (data) => {
        //   bufferData += data.toString(); // Á¥ØÂä†Êé•Êî∂Âà∞ÁöÑ‰∏≤Âè£Êï∞ÊçÆ
  
        //   // Âà§Êñ≠ÊòØÂê¶‰∏ÄÊù°Ê∂àÊÅØÁªìÊùüÔºàÊ†πÊçÆ‰Ω†ÁöÑËÆæÂ§áÂçèËÆÆÔºåËøôÈáå‰ª• \r\n ‰∏∫ÁªìÂ∞æÔºâ
        //   if (bufferData.endsWith('\r\n')) {
        //     const message = bufferData.trim(); // ÂéªÈô§ \r\n ÂíåÁ©∫Ê†º
        //     bufferData = ''; // Ê∏ÖÁ©∫ÁºìÂ≠òÔºåÂáÜÂ§á‰∏ã‰∏ÄÊù°
        //     console.log(typeof message)
        //     if(message=='["success"]'){
        //       console.log(message)
        //     }
        
        //     // Â∞ùËØïÂà§Êñ≠ÊòØ‰∏çÊòØ JSON Êï∞ÁªÑ
        //     if (message.startsWith('[') && message.endsWith(']')) {
        //       // console.log('recive array'+message)
        //       try {
        //         const parsedArray = JSON.parse(message);
        //         // console.log('‚úÖ Êé•Êî∂Âà∞Êï∞ÁªÑ:', parsedArray);
        
                
        //         // ÂπøÊí≠ÊàñÂÖ∂‰ªñÊìç‰Ωú...
        //         socket.getSocket()?.send(JSON.stringify({
        //           type: 'serialData',
        //           data: { message: parsedArray }
        //         }));
        
        //       } catch (err) {
        //         // console.error('JSON Ëß£ÊûêÂ§±Ë¥•:', err.message);
        //       }
        //     } else {
        //       // console.log('recive string:', message);
        
        //       socket.getSocket()?.send(JSON.stringify({
        //         type: 'serialData',
        //         data: { message }
        //       }));
        
        //       // ‰Ω†‰πüÂèØ‰ª•ÂÅö‰∏Ä‰∫õÂà§Êñ≠
        //       if (message === 'success') {
        //         console.log('SUCCESS');
        //       } else if (message === 'fail') {
        //         console.log('FAILED');
        //       }
        //     }
        //   }
        // });



        
        

        // Êâ´Êèè‰∏≤Âè£ÂàóË°®ÔºåÂ∞ùËØïËØÜÂà´ micro:bit
        const ports = await SerialPort.list();
        const targetPortInfo = ports.find(p => p.path === port);

        const isMicrobit = targetPortInfo &&
          targetPortInfo.vendorId === '0D28' &&
          ['0204', '0205'].includes(targetPortInfo.productId?.toUpperCase?.());

        if (isMicrobit) {
          console.log('ËØÜÂà´‰∏∫ Micro:bit ËÆæÂ§áÔºåÂ∞ùËØïÂàùÂßãÂåñ USB ‰∏é‰∏≤Âè£ËøûÊé•');

          // Ëé∑Âèñ USB ËÆæÂ§á
          setDeviceState(['usbDevice',usb.findByIds(0x0d28, parseInt(targetPortInfo.productId, 16))])
          if (!getDeviceState().usbDevice) {
            return { success: false, error: 'Êú™ÊâæÂà∞ÂåπÈÖçÁöÑ USB ËÆæÂ§á' };
          }

          try {
            getDeviceState().usbDevice.open();
            if (getDeviceState().usbDevice.interfaces?.length > 0) {
              getDeviceState().usbDevice.interfaces[0].claim();
            }
            console.log('usb connect succcess')
          } catch (err) {
            console.warn('USB ÊâìÂºÄÂ§±Ë¥•:', err.message);
          }

          // ÂàùÂßãÂåñ‰∏≤Âè£ÔºàÂíå‰πãÂâç‰∏ÄËá¥Ôºâ
          setDeviceState(['serialPort',new SerialPort({
            path: port,
            baudRate: 115200,
            dataBits: 8,
            stopBits: 1,
            parity: 'none',
            autoOpen: false
          })])

          await new Promise((resolve, reject) => {
            getDeviceState().serialPort.open(err => (err ? reject(err) : resolve()));
          });

          console.log('‰∏≤Âè£ËøûÊé•ÊàêÂäüÔºàMicro:bitÔºâ');
          setPort(getDeviceState().serialPort);
          setPortCom(port)

          // const parserInstance = serial.pipe(new ReadlineParser({ delimiter: '\r\n' }));
          setDeviceState(['parser',getDeviceState().serialPort.pipe(new ReadlineParser({ delimiter: '\r\n' }))])

          

          setupSerialListeners()


          await new Promise(resolve => setTimeout(resolve, 1000))

          await sendSerialCommand('\x03'); 
          await sendSerialCommand('from microbit import *\r',200);
          await sendSerialCommand('from ICreate import *\r',200);
          await sendSerialCommand('display.show(Image.HEART)\n\r', 200);
          // let bufferData = '';
          // getDeviceState().parser.on('data', (data) => {
          //   bufferData += data.toString();
          //   if (bufferData.endsWith('\r\n')) {
          //     const message = bufferData.trim();
          //     bufferData = '';

          //     try {
          //       const parsed = JSON.parse(message);
          //       socket.getSocket()?.send(JSON.stringify({
          //         type: 'serialData',
          //         data: { message: parsed }
          //       }));
          //     } catch {
          //       socket.getSocket()?.send(JSON.stringify({
          //         type: 'serialData',
          //         data: { message }
          //       }));
          //     }
          //   }
          // });

          // getDeviceState().serialPort.on('close', () => {
          //   socket.getSocket()?.send(JSON.stringify({
          //     type: 'isOpenPort',
          //     data: { message: false }
          //   }));
          // });

          // getDeviceState().serialPort.on('error', err => console.error('‰∏≤Âè£ÈîôËØØ:', err));


          return { success: true, microbit: true };
        } else {
          // Èùû Micro:bit ‚Äî ÂéüÊúâÈÄªËæë
          console.log('Èùû Micro:bit ‰∏≤Âè£Ôºå‰ΩøÁî®ÂéüÂßãËøûÊé•ÊñπÂºè');

          PORT = new SerialPort({
            path: port,
            baudRate: 115200,
            dataBits: 8,
            stopBits: 1,
            parity: 'none'
          });

          PORT.on('open', () => {
            console.log('‰∏≤Âè£ÊâìÂºÄÊàêÂäü');
            setPort(PORT);
            setPortCom(port)

            socket.getSocket()?.send(JSON.stringify({
              type: 'isOpenPort',
              data: { message: true }
            }));

            ipc.on('is-connected', (event) => {
              event.returnValue = { flag: true };
            });
          });

          let bufferData = '';
          PORT.on('data', (data) => {
            bufferData += data.toString();
            if (bufferData.endsWith('\r\n')) {
              const message = bufferData.trim();
              bufferData = '';

              try {
                const parsed = JSON.parse(message);
                socket.getSocket()?.send(JSON.stringify({
                  type: 'serialData',
                  data: { message: parsed }
                }));
              } catch {
                socket.getSocket()?.send(JSON.stringify({
                  type: 'serialData',
                  data: { message }
                }));
              }
            }
          });

          PORT.on('close', () => {
            console.log('‰∏≤Âè£ÂÖ≥Èó≠');
            setPortCom('')
            socket.getSocket()?.send(JSON.stringify({
              type: 'isOpenPort',
              data: { message: false }
            }));
          });

          PORT.on('error', err => console.error('‰∏≤Âè£ÈîôËØØ:', err));

          return { success: true, microbit: false };
        }
  
  
        
  
      })
      

      // ÁõëÂê¨Êñ≠ÂºÄÊàñÂºÇÂ∏∏
      function setupSerialListeners() {
        // ÂÖàÁßªÈô§ÊóßÁõëÂê¨Âô®
        if (getDeviceState().parser) {
          getDeviceState().parser.removeAllListeners();
        }
      
        getDeviceState().serialPort.on('data', data => {
          const buffer = getDeviceState().serialBuffer + data;
          setDeviceState(['serialBuffer',buffer])
          // console.log(data)
          if (getDeviceState().serialBuffer.includes('>>>') && getDeviceState().currentResolve) {
            const response = getDeviceState().serialBuffer;
            console.log("####",response)
            // deviceState.serialBuffer = '';
            setDeviceState(['serialBuffer',''])
            getDeviceState().currentResolve(response);
            // deviceState.currentResolve = null;
            setDeviceState('currentResolve',null)
          }


         
        });
      
        getDeviceState().serialPort.once('close', () => {
          // portCom=''
          setPortCom('')
          disconnectDevice().catch(console.error);
        });
      
        getDeviceState().serialPort.once('error', err => {
          disconnectDevice().catch(console.error);
        });
      }


      async function disconnectDevice() {
        const deviceState = getDeviceState();

        // ÂÖ≥Èó≠‰∏≤Âè£
        if (deviceState.serialPort && deviceState.serialPort.isOpen) {
          await new Promise((resolve, reject) => {
            deviceState.serialPort.close((err) => {
              if (err) reject(err);
              else resolve();
            });
          });
        }

        // ÂÖ≥Èó≠ USB ËÆæÂ§á
        try {
          if (deviceState.usbDevice) {
            if (deviceState.usbDevice.interfaces?.[0]?.isKernelDriverActive?.()) {
              deviceState.usbDevice.interfaces[0].detachKernelDriver();
            }
            if (deviceState.usbDevice.interfaces?.[0]?.claimed) {
              deviceState.usbDevice.interfaces[0].release(true, () => {});
            }
            deviceState.usbDevice.close();
          }
        } catch (err) {
          console.warn('USB Ê∏ÖÁêÜÊó∂ÂºÇÂ∏∏:', err.message);
        }

        // Ê∏ÖÁêÜÁä∂ÊÄÅ
        setDeviceState(['serialPort', null]);
        setDeviceState(['usbDevice', null]);
        setDeviceState(['parser', null]);
        setDeviceState(['replActive', false]);
        setDeviceState(['serialBuffer', '']);
        setDeviceState(['currentResolve', null]);

        // ÈÄöÁü•ÂâçÁ´Ø
        if (socket.getSocket()) {
          socket.getSocket().send(JSON.stringify({
            type: 'isOpenPort',
            data: { message: false }
          }));
        }
      }

      ipc.handle('disconnect', async (event) =>{

        //   if (PORT && PORT.isOpen) {
        //     try {
        //         // Á≠âÂæÖ‰∏≤Âè£ÂÖ≥Èó≠ÂÆåÊàê
        //         await new Promise((resolve, reject) => {
        //             PORT.close((err) => {
        //                 if (err) {
        //                     console.error('ÂÖ≥Èó≠‰∏≤Âè£Êó∂ÂèëÁîüÈîôËØØ:', err.message);
        //                     reject(err); // ÊãíÁªù Promise
        //                 } else {
        //                     console.log('‰∏≤Âè£Â∑≤ÊàêÂäüÂÖ≥Èó≠');

        //                     // Ê∏ÖÁêÜÊìç‰Ωú
        //                     setPort(null);
        //                     portCom = '';

        //                     if (socket.getSocket()) {
        //                         socket.getSocket().send(JSON.stringify({
        //                             type: 'isOpenPort',
        //                             data: { message: false }
        //                         }));
        //                     }

        //                     PORT.removeAllListeners();
        //                     resolve(); // ÊàêÂäü
        //                 }
        //             });
        //         });

        //         return { success: true };

        //     } catch (err) {
        //         return { success: false, error: err.message };
        //     }
        // } else {
        //     return { success: true, message: '‰∏≤Âè£Êú™ÊâìÂºÄ' };
        // }



        // Ê£ÄÊü•ÂΩìÂâçÁ´ØÂè£ÊòØÂê¶‰∏∫ micro:bit
        const ports = await SerialPort.list();
        const currentPortInfo = ports.find(p => p.path === getPortCom());

        const isMicrobit = currentPortInfo &&
          currentPortInfo.vendorId === '0D28' &&
          ['0204', '0205'].includes(currentPortInfo.productId?.toUpperCase?.());

        try {
          if (isMicrobit) {
            await disconnectDevice();

            // Ê∏ÖÁ©∫Á´ØÂè£ËÆ∞ÂΩï
            setPort(null);
            // portCom = '';
            setPortCom('')

            console.log('Micro:bit is disconnected');
            return { success: true, microbit: true };
          }

          // Èùû Micro:bit ‰∏≤Âè£Â§ÑÁêÜÔºàÂéüÈÄªËæëÔºâ
          if (PORT && PORT.isOpen) {
            await new Promise((resolve, reject) => {
              PORT.close((err) => {
                if (err) {
                  console.error('serial close failed:', err.message);
                  reject(err);
                } else {
                  console.log('serial close success');

                  setPort(null);
                  // portCom = '';
                  setPortCom('')

                  if (socket.getSocket()) {
                    socket.getSocket().send(JSON.stringify({
                      type: 'isOpenPort',
                      data: { message: false }
                    }));
                  }

                  PORT.removeAllListeners();
                  resolve();
                }
              });
            });

            return { success: true, microbit: false };
          } else {
            return { success: true, message: '‰∏≤Âè£Êú™ÊâìÂºÄ' };
          }
        } catch (err) {
          return { success: false, error: err.message };
        }
      })
  
      const session = require('electron').session;
      session.defaultSession.setPermissionCheckHandler((permission, details) => {
        if (permission === 'serial') {
          return true; // ÂÖÅËÆ∏ËÆøÈóÆ‰∏≤Âè£ËÆæÂ§á
        }
        return false;
      });
  
      
  
      let port;
      let writer;
      let reader;
      let PORTS=[]
      async function init(){
        // await SerialPort.list().then(ports => {
        //   ports.forEach(port=>{
        //     console.log(port.path)
        //     PORTS.push(port.path)
        //     // console.log(PORTS)
        //   })
        // })
        // console.log(PORTS)

        try {
          PORTS=[]
          const ports = await SerialPort.list();  // ‚úÖ Áõ¥Êé•‰ΩøÁî® await Ëé∑ÂèñÁªìÊûú
          // ports.forEach(port => {
          //   console.log(port.path);
          //   PORTS.push(port.path);
          // });

          // console.log(ports)

          PORTS = ports.map(port => ({
            path: port.path,
             label: (port.vendorId === '0D28' && ['0204', '0205'].includes(port.productId)) 
              ? `${port.path}ÔºàMicrobitÔºâ`
              : port.path
          }));

          // console.log(PORTS);
        } catch (error) {
          console.error('Ëé∑Âèñ‰∏≤Âè£ÂàóË°®Â§±Ë¥•:', error);
        }
        
      
  
      }

      init()
      setInterval(init, 3000);

      ipc.on('get-ports', (event) => {
        // init()
        event.returnValue = {
          PORTS
        }
      });
      
    
    
    this.loadURL('connect://./connect-device.html');
  }


  getDimensions () {
    return {
      width: 500,
      height: 400
    };
  }

  getPreload () {
    return 'connect-device';
  }

  isPopup () {
    return true;
  }

  static show () {
    const window = AbstractWindow.singleton(ConnectWindow);
    window.show();
  }
}

module.exports = ConnectWindow;
